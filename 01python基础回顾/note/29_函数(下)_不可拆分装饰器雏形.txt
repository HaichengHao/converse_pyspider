装饰器本质上是一个闭包，
作用:在不改变原有函数调用的情况下，给函数增加新的功能
直白些:可以在函数前后添加新功能，但不改变原来的功能
核心作用:在目标函数之前或者之后添加新的功能，但不改变原来的代码
适用环境:
    例如在员工信息管理系统使用任何功能之前必须先进行登录操作
    还有日志功能，方便对操作信息进行记录
实际雏形的写法
def wrapper(fn):  wrapper:装饰器 fn: 目标函数
    def inner():
      #在目标函数执行之前的操作代码
      fn()  #执行目标函数
      #在目标函数执行之后进行的操作
    return inner <--记住，一定要返回inner函数，记住不能加括号，加括号就是把目标函数执行的结果返回

