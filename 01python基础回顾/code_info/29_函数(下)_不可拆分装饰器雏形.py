# editor: 百年
# time: 2024/3/7 16:50
'''
内容回顾：
    1.函数可以作为参数进行传递
    2.函数可以作为返回值返回
    3.函数名称可以像变量一样进行赋值操作

'''
# 回顾
'''
# 函数可以作为参数传递
# 函数可以作为返回值返回
def func1():
    print('我是一个函数')

def func2(fn): #定义一个执行函数的函数func2
    fn()

# 把函数func1作为参数传递到func2中，这样利用func2执行func1
# 即函数代理
func2(func1)'''

# 函数名可以像变量一样进行赋值操作
'''
def func1():
    print('我是函数1')
def func2():
    print('我是函数2')

# 将函数进行赋值操作，把func2赋值给func1
func1=func2
# 尝试执行func1看看是不是想要的结果
func1()
# 我是函数2 <--可见其本质上是运行了函数func2

'''

# 装饰器 >要求记住最后的结论

# 打游戏想开挂，但是每次开启和关闭外挂都很麻烦
# print('开挂')
# play_cf()
# print('关闭外挂')

# 创建一个管家函数，能在打游戏前自动开启外挂，结束后自动关闭外挂
'''
def magic():
    print('外挂打开')
    play_lol()  #如果这样写，那就变成了函数代理的定义了，我们不想让管家magic帮我们决定游戏是否打开
    print('外挂关闭')

'''
# 所以，我们应该这样写
def magic(game):
    def inner():
        print('外挂开启')
        game()
        print('外挂关闭')
    return inner

# play_cf=magic(play_cf) #让魔法把游戏重新封装一遍
# # 调用魔法，即执行inner模块,让其完成游戏开启前打开外挂，游戏结束后关闭外挂的功能
# play_cf()  #结合闭包那节观察代码，即相当于inner函数被执行，即inner()
# '''
# 外挂开启
# 爱玩，虽然不准
# 外挂关闭
# '''
#
# play_lol=magic(play_lol)  #相当于inner
# play_lol()  #相当于inner()
'''
外挂开启
爱玩，虽然菜
外挂关闭'''
@magic #此时相当于play_lol=magic(play_lol)
def play_lol():
    print('爱玩，虽然菜')
@magic
def play_cf():
    print('爱玩，虽然不准')
@magic
def play_qcar():
    print('爱玩，不会漂移')

play_cf()
'''
外挂开启
爱玩，虽然不准
外挂关闭
'''

'''
装饰器本质上是一个闭包，
作用:在不改变原有函数调用的情况下，给函数增加新的功能
直白些:可以在函数前后添加新功能，但不改变原来的功能
核心作用:在目标函数之前或者之后添加新的功能，但不改变原来的代码
适用环境:
    例如在员工信息管理系统使用任何功能之前必须先进行登录操作
    还有日志功能，方便对操作信息进行记录
实际雏形的写法
def wrapper(fn):  wrapper:装饰器 fn: 目标函数
    def inner():
      #在目标函数执行之前的操作代码
      fn()  #执行目标函数
      #在目标函数执行之后进行的操作
    return inner <--记住，一定要返回inner函数，记住不能加括号，加括号就是把目标函数执行的结果返回
'''